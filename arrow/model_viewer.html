<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>GLSL 模型查看器</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script id="vertexShader" type="x-shader/x-vertex">
        attribute vec2 position;
        void main() {
            gl_Position = vec4(position, 0.0, 1.0);
        }
    </script>
    <script id="fragmentShader" type="x-shader/x-fragment">
        precision mediump float;
        uniform vec2 resolution;
        uniform float time;
        uniform vec3 cameraPosition;
        uniform mat4 cameraMatrix;

        // 导入模型数据
        #include "model_data.glsl"

        void main() {
            // 计算归一化设备坐标
            vec2 uv = (gl_FragCoord.xy / resolution) * 2.0 - 1.0;
            uv.x *= resolution.x / resolution.y;
            
            // 相机和光线设置
            vec3 rayOrigin = cameraPosition;
            vec3 rayDir = normalize(vec3(uv.x, uv.y, -1.0));
            rayDir = (cameraMatrix * vec4(rayDir, 0.0)).xyz;
            
            // 缩放和居中模型
            rayOrigin = (rayOrigin - MODEL_CENTER) * MODEL_SCALE;
            
            // 渲染模型
            vec4 modelColor = renderModel(rayOrigin, rayDir);
            
            // 输出颜色
            if (modelColor.a > 0.0) {
                gl_FragColor = modelColor;
            } else {
                // 背景颜色
                vec3 bgColor = vec3(0.2, 0.3, 0.4);
                gl_FragColor = vec4(bgColor, 1.0);
            }
        }
    </script>
    <script>
        // 初始化WebGL
        const canvas = document.getElementById('canvas');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        const gl = canvas.getContext('webgl');
        if (!gl) {
            alert('WebGL不可用');
            return;
        }
        
        // 加载着色器
        function loadShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('着色器编译错误:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }
        
        // 加载模型数据
        fetch('model_data.glsl')
            .then(response => response.text())
            .then(modelData => {
                // 替换片段着色器中的#include
                const fragmentShaderSource = document.getElementById('fragmentShader').textContent
                    .replace('#include "model_data.glsl"', modelData);
                
                const vertexShaderSource = document.getElementById('vertexShader').textContent;
                
                // 创建着色器程序
                const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
                const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
                
                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.error('程序链接错误:', gl.getProgramInfoLog(program));
                    return;
                }
                
                // 创建顶点缓冲区
                const positionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                    -1, -1,
                     1, -1,
                    -1,  1,
                     1,  1
                ]), gl.STATIC_DRAW);
                
                // 获取属性和uniform位置
                const positionLocation = gl.getAttribLocation(program, 'position');
                const resolutionLocation = gl.getUniformLocation(program, 'resolution');
                const timeLocation = gl.getUniformLocation(program, 'time');
                const cameraPositionLocation = gl.getUniformLocation(program, 'cameraPosition');
                const cameraMatrixLocation = gl.getUniformLocation(program, 'cameraMatrix');
                
                // 启用顶点属性
                gl.enableVertexAttribArray(positionLocation);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
                
                // 相机控制
                let cameraAngleX = 0;
                let cameraAngleY = 0;
                let cameraDistance = 3.0;
                let isDragging = false;
                let lastMouseX = 0;
                let lastMouseY = 0;
                
                canvas.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                });
                
                canvas.addEventListener('mouseup', () => {
                    isDragging = false;
                });
                
                canvas.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        const deltaX = e.clientX - lastMouseX;
                        const deltaY = e.clientY - lastMouseY;
                        
                        cameraAngleY += deltaX * 0.01;
                        cameraAngleX += deltaY * 0.01;
                        
                        // 限制垂直旋转角度
                        cameraAngleX = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraAngleX));
                        
                        lastMouseX = e.clientX;
                        lastMouseY = e.clientY;
                    }
                });
                
                canvas.addEventListener('wheel', (e) => {
                    cameraDistance += e.deltaY * 0.01;
                    cameraDistance = Math.max(1.0, Math.min(10.0, cameraDistance));
                    e.preventDefault();
                });
                
                // 渲染循环
                function render(time) {
                    time *= 0.001; // 转换为秒
                    
                    // 调整画布大小
                    if (canvas.width !== window.innerWidth || canvas.height !== window.innerHeight) {
                        canvas.width = window.innerWidth;
                        canvas.height = window.innerHeight;
                        gl.viewport(0, 0, canvas.width, canvas.height);
                    }
                    
                    // 计算相机位置和矩阵
                    const cosY = Math.cos(cameraAngleY);
                    const sinY = Math.sin(cameraAngleY);
                    const cosX = Math.cos(cameraAngleX);
                    const sinX = Math.sin(cameraAngleX);
                    
                    const cameraPosition = [
                        cameraDistance * cosY * cosX,
                        cameraDistance * sinX,
                        cameraDistance * sinY * cosX
                    ];
                    
                    // 简单的相机矩阵（仅旋转）
                    const cameraMatrix = [
                        cosY, 0, -sinY, 0,
                        sinY * sinX, cosX, cosY * sinX, 0,
                        sinY * cosX, -sinX, cosY * cosX, 0,
                        0, 0, 0, 1
                    ];
                    
                    // 使用着色器程序
                    gl.useProgram(program);
                    
                    // 设置uniform
                    gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
                    gl.uniform1f(timeLocation, time);
                    gl.uniform3fv(cameraPositionLocation, cameraPosition);
                    gl.uniformMatrix4fv(cameraMatrixLocation, false, cameraMatrix);
                    
                    // 绘制
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                    
                    requestAnimationFrame(render);
                }
                
                requestAnimationFrame(render);
            })
            .catch(error => console.error('加载模型数据失败:', error));
    </script>
</body>
</html>
