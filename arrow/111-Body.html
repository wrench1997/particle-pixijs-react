<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="UTF-8" />
    <title>GLTF 3D 模型渲染 - 111-Body.gltf</title>
    <script type="module">
      import {
        Application,
        Mesh,
        Geometry,
        Shader,
        Container
      } from 'https://cdn.jsdelivr.net/npm/pixi.js@8/dist/pixi.mjs';

      (async () => {
        try {
          // 创建应用
          const app = new Application();
          await app.init({
            height: window.innerHeight,
            width: window.innerWidth,
            background: '#1a1a1a',
            antialias: true
          });
          document.body.appendChild(app.view);
          
          // 从GLTF数据创建几何体
          const createGeometryFromGLTF = () => {
            // 解码base64数据
            const binData = atob("SmopIwAAAAAN4+G8SmopIwrXIzwN4+G8mNvIugrXIzyuieG8IIxIuwrXIzzYfeC84gWWuwrXIzxgwN68/k7HuwrXIzymUty8ZPr3uwrXIzyVNtm8yfATvArXIzyjbtW8UG8rvArXIzzP/dC8MGZCvArXIzyc58u8PcNYvArXIzwRMMa8xHRuvArXIzyz27+8zrSBvArXIzyE77i8mMiLvArXIzwAcbG8xm2VvArXIzwUZqm8tpyevArXIzwc1aC8JU6nvArXIzzixJe8MXuvvArXIzyQPI68Yh23vArXIzyxQ4S8ri6+vArXIzxTxHO8fanEvArXIzxhQF68r4jKvArXIzySDEi8ncfPvArXIzx3OjG8I2LUvArXIzwg3Bm8mlTYvArXIzwKBAK845vbvArXIzwkitO7ZzXevArXIzzSZKK7Fh/gvArXIzz/fWG7blfhvArXIzzc//q6dt3hvArXIzxx9Mi5xrDhvArXIzxkrZY6gNHgvArXIzxVkC87VUDfvArXIzyGn4k7gv7cvArXIzz8Cbs70Q3avArXIzxx4Os7lXDWvArXIzwh/g08qinSvArXIzyumyU8dDzNvArXIzwwtjw816zHvArXIzxfO1M8On/BvArXIzxqGWk8gbi6vArXIzwBP348CF6zvArXIzy2TYk8oXWrvArXIzxFD5M8jgWjvArXIzx3XJw8fBSavArXIzzvLaU8fqmQvArXIzyzfK08CcyGvArXIzwxQrU80wd5vArXIzxBeLw8h7JjvArXIzwvGcM8D6lNvArXIzy8H8k82vw2vArXIzwkh8482r8fvArXIzwgS9M8cgQIvArXIzzrZ9c807rfuwrXIzxE2to8ubuuuwrXIzxwn908t2R6uwrXIzw+td8824sWuwrXIzwIGuE8ee9IugrXIzy0zOE8ee9IOgrXIzy0zOE824sWOwrXIzwIGuE8t2R6OwrXIzw+td88ubuuOwrXIzxwn90807rfOwrXIzxE2to8cgQIPArXIzzrZ9c82r8fPArXIzwgS9M82vw2PArXIzwkh848D6lNPArXIzy8H8k8h7JjPArXIzwvGcM80wd5PArXIzxBeLw8CcyGPArXIzwxQrU8fqmQPArXIzyzfK08fBSaPArXIzzvLaU8jgWjPArXIzx3XJw8oXWrPArXIzxFD5M8CF6zPArXIzy2TYk8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lXDWvArXIzwh/g08qinSvArXIzyumyU8dDzNvArXIzwwtjw816zHvArXIzxfO1M8On/BvArXIzxqGWk8gbi6vArXIzwBP348CF6zvArXIzy2TYk8oXWrvArXIzxFD5M8jgWjvArXIzx3XJw8fBSavArXIzzvLaU8fqmQvArXIzyzfK08CcyGvArXIzwxQrU80wd5vArXIzxBeLw8h7JjvArXIzwvGcM8D6lNvArXIzy8H8k82vw2vArXIzwkh8482r8fvArXIzwgS9M8cgQIvArXIzzrZ9c807rfuwrXIzxE2to8ubuuuwrXIzxwn908t2R6uwrXIzw+td8824sWuwrXIzwIGuE8ee9IugrXIzy0zOE8ee9IOgrXIzy0zOE824sWOwrXIzwIGuE8t2R6OwrXIzw+td88ubuuOwrXIzxwn90807rfOwrXIzxE2to8cgQIPArXIzzrZ9c82r8fPArXIzwgS9M82vw2PArXIzwkh848D6lNPArXIzy8H8k8h7JjPArXIzwvGcM80wd5PArXIzxBeLw8CcyGPArXIzwxQrU8fqmQPArXIzyzfK08fBSaPArXIzzvLaU8jgWjPArXIzx3XJw8oXWrPArXIzxFD5M8CF6zPArXIzy2TYk8gbi6PArXIzwBP348On/BPArXIzxqGWk816zHPArXIzxfO1M8dDzNPArXIzwwtjw8qinSPArXIzyumyU8lXDWPArXIzwh/g080Q3aPArXIzxx4Os7gv7cPArXIzz8Cbs7VUDfPArXIzyGn4k7gNHgPArXIzxVkC87xrDhPArXIzxkrZY6dt3hPArXIzxx9Mi5blfhPArXIzzc//q6Fh/gPArXIzz/fWG7ZzXePArXIzzSZKK745vbPArXIzwkitO7mlTYPArXIzwKBAK8I2LUPArXIzwg3Bm8ncfPPArXIzx3OjG8r4jKPArXIzySDEi8fanEPArXIzxhQF68ri6+PArXIzxTxHO8Yh23PArXIzyxQ4S8MXuvPArXIzyQPI68JU6nPArXIzzixJe8tpyePArXIzwc1aC8xm2VPArXIzwUZqm8mMiLPArXIzwAcbG8zrSBPArXIzyE77i8xHRuPArXIzyz27+8PcNYPArXIzwRMMa8MGZCPArXIzyc58u8UG8rPArXIzzP/dC8yfATPArXIzyjbtW8ZPr3OwrXIzyVNtm8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80nCPgAAAAAp2my/oKmnPgAAAACK4nG/oYSMPgAAAACFK3a/5OBhPgAAAAC2sXm/ygUqPgAAAABScny/TUjjPQAAAAAta36/XaJjPQAAAAC3mn+/AAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAdAABAAAAdAACAAEAdQADAAIAdQAEAAMAdQACAHQAdgAEAHUAdwAFAAQAdwAGAAUAdwAEAHYAeAAGAHcAeQAHAAYAeQAIAAcAeQAGAHgAegAIAHkAewAJAAgAewAIAHoAfAAKAAkAfAALAAoAfAAJAHsAfQAMAAsAfQALAHwAfgAMAH0AfwANAAwAfwAMAH4AgAAOAA0AgAANAH8AgQAPAA4AgQAOAIAAggAQAA8AggAPAIEAgwARABAAgwAQAIIAhAASABEAhAARAIMAhQATABIAhQAUABMAhQASAIQAhgAUAIUAhwAUAIYAhwAVABQAiAAVAIcAiAAWABUAiAAXABYAiQAXAIgAigAYABcAigAXAIkAiwAZABgAiwAYAIoAjAAaABkAjAAZAIsAjQAbABoAjQAcABsAjQAaAIwAjgAdABwAjgAcAI0AjwAeAB0AjwAdAI4AkAAeAI8AkQAfAB4AkQAeAJAAkgAgAB8AkgAhACAAkgAfAJEAkwAiACEAkwAhAJIAlAAiAJMAlQAjACIAlQAkACMAlQAiAJQAlgAkAJUAlwAlACQAlwAkAJYAmAAmACUAmAAlAJcAmQAnACYAmQAmAJgAmgAoACcAmgAnAJkAmwApACgAmwAoAJoAnAAqACkAnAApAJsAnQArACoAnQAqAJwAngAsACsAngArAJ0AnwAsAJ4AnwAtACwAoAAtAJ8AoAAuAC0AoAAvAC4AoQAvAKAAoQAwAC8AogAwAKEAogAxADAAowAxAKIApAAxAKMApAAyADEApQAyAKQApQAzADIApgAzAKUApgA0ADMApwA0AKYApwA1ADQAqAA1AKcAqAA2ADUAqQA2AKgAqQA3ADYAqgA3AKkAqgA4ADcAqwA4AKoAqwA5ADgArAA5AKsArAA6ADkArQA7ADoArQA6AKwArgA8ADsArgA7AK0ArwA9ADwArwA8AK4AsAA+AD0AsAA9AK8AsQA/AD4AsQA+ALAAsgBAAD8AsgA/ALEAswBBAEAAswBAALIAtABCAEEAtABBALMAtQBDAEIAtQBCALQAtgBEAEMAtgBDALUAtwBEALYAtwBFAEQAtwBGAEUAuABGALcAuQBGALgAuQBHAEYAuQBIAEcAugBIALkAuwBIALoAuwBJAEgAvABJALsAvABKAEkAvQBKALwAvQBLAEoAvQBMAEsAvgBMAL0AvwBMAL4AvwBNAEwAwABNAL8AwABOAE0AwQBOAMAAwQBPAE4AwQBQAE8AwgBQAMEAwgBRAFAAwwBRAMIAxABRAMMAxABSAFEAxQBSAMQAxQBTAFIAxgBTAMUAxgBUAFMAxgBVAFQAxwBVAMYAyABVAMcAyABWAFUAyQBWAMgAyQBXAFYAyQBYAFcAygBYAMkAygBZAFgAywBZAMoAzABZAMsAzABaAFkAzABbAFoAzQBbAMwAzgBcAFsAzgBdAFwAzgBbAM0AzwBeAF0AzwBdAM4A0ABeAM8A0QBeANAA0QBfAF4A0QBgAF8A0gBgANEA0gBhAGAA0wBhANIA1ABhANMA1ABiAGEA1QBiANQA1QBjAGIA1gBlAGQA1gBjANUA1gBkAGMA1wBlANYA2ABmAGUA2ABnAGYA2ABlANcA2QBnANgA2gBoAGcA2gBnANkA2wBpAGgA2wBoANoA3ABqAGkA3ABpANsA3QBrAGoA3QBqANwA3gBsAGsA3gBtAGwA3gBrAN0A3wBuAG0A3wBtAN4A4ABvAG4A4ABuAN8A4QBvAOAA4gBwAG8A4gBvAOEA4wBxAHAA4wBwAOIAcwByAHEAcwBxAOMAKAAqACkALQAsACsAJAAmACUAJAAnACYAJAAoACcAMQAqACgAMQAtACsAMQArACoAMQAuAC0AMQAvAC4AMQAwAC8AIwAoACQAIgAxACgAIgAoACMAMwAyADEAIAAiACEAIAAxACIANwA0ADMANwA1ADQANwA2ADUAHQAfAB4AOQA4ADcAOgA3ADMAOgA5ADcAOwAzADEAOwA6ADMAPAA7ADEAGAAaABkAGAAbABoAGAAcABsAGAAdABwAFwAdABgAPwA+AD0AFQAXABYAFQAgAB8AFQAfAB0AFQAdABcAQAA9ADwAQAA/AD0AEgAUABMAEgAVABQAQwBCAEEAEQAVABIARQBAADwARQBDAEEARQBBAEAARQBEAEMADwAVABEADwARABAADgAVAA8ASABGAEUASABHAEYASQBIAEUACwANAAwACwAOAA0ACwAVAA4ACwAxACAACwAgABUASgBJAEUASwBKAEUATABFADwATABLAEUACAAKAAkACAALAAoABgAIAAcABgALAAgATwBMADwATwBNAEwATwBOAE0ABQALAAYAAwAFAAQAAwALAAUAUgBPADwAUgBQAE8AUgBRAFAAUwBSADwAAQADAAIAAQALAAMAVABTADwAVAA8ADEAVQBUADEAcAABAAAAVwBWAFUAbQBvAG4AbQBwAG8AbQALAAEAbQABAHAAWgBYAFcAWgBZAFgAWwBaAFcAWwBXAFUAXABbAFUAXgBdAFwAZwBpAGgAZwBqAGkAZwBrAGoAXwBeAFwAZQBnAGYAYQBfAFwAYQBgAF8AZABsAGsAZABtAGwAZABrAGcAZABnAGUAZAAxAAsAZAALAG0AYgBcAFUAYgBhAFwAYgAxAGQAYgBVADEAYwBiAGQAICAoACkAKgAtACsALAAkACUAJgAkACYAJwAkACcAKAAxACgAKgAxACsALQAxACoAKwAxAC0ALgAxAC4ALwAxAC8AMAAjACQAKAAiACgAMQAiACMAKAAzADEAMgAgACEAIgAgACIAMQA3ADMANAA3ADQANQA3ADUANgAdAB4AHwA5ADcAOAA6ADMANwA6ADcAOQA7ADEAMwA7ADMAOgA8ADEAOwAYABkAGgAYABoAGwAYABsAHAAYABwAHQAXABgAHQA/AD0APgAVABYAFwAVAB8AIAAVAB0AHwAVABcAHQBAADwAPQBAAD0APwASABMAFAASABQAFQBDAEEAQgARABIAFQBFADwAQABFAEEAQwBFAEAAQQBFAEMARAAPABEAFQAPABAAEQAOAA8AFQBIAEUARgBIAEYARwBJAEUASAALAAwADQALAA0ADgALAA4AFQALACAAMQALABUAIABKAEUASQBLAEUASgBMADwARQBMAEUASwAIAAkACgAIAAoACwAGAAcACAAGAAgACwBPADwATABPAEwATQBPAE0ATgAFAAYACwADAAQABQADAAUACwBSADwATwBSAE8AUABSAFAAUQBTADwAUgABAAIAAwABAAMACwBUADwAUwBUADEAPABVADEAVABwAAAAAQBXAFUAVgBtAG4AbwBtAG8AcABtAAEACwBtAHAAAQBaAFcAWABaAFgAWQBbAFcAWgBbAFUAVwBcAFUAWwBeAFwAXQBnAGgAaQBnAGkAagBnAGoAawBfAFwAXgBlAGYAZwBhAFwAXwBhAF8AYABkAGsAbABkAGwAbQBkAGcAawBkAGUAZwBkAAsAMQBkAG0ACwBiAFUAXABiAFwAYQBiAGQAMQBiADEAVQBjAGQAYgAgIA==");
            const buffer = new ArrayBuffer(binData.length);
            const view = new Uint8Array(buffer);
            for (let i = 0; i < binData.length; i++) {
              view[i] = binData.charCodeAt(i);
            }
            
            // 解析GLTF数据
            const gltfData = {"accessors": [{"bufferView": 0, "byteOffset": 0, "componentType": 5126, "count": 228, "max": [0.027571421921584835, 0.01, 0.027563430201120783], "min": [-0.027571421921584835, 0.0, -0.027574086], "type": "VEC3"}, {"bufferView": 0, "byteOffset": 2736, "componentType": 5126, "count": 113, "max": [0.027571421921584835, 0.0, 0.027563430201120783], "min": [-0.027571421921584835, 0.0, -0.027574086], "type": "VEC3"}, {"bufferView": 0, "byteOffset": 4092, "componentType": 5126, "count": 113, "max": [0.027571421921584835, 0.01, 0.027563430201120783], "min": [-0.027571421921584835, 0.01, -0.027574086], "type": "VEC3"}, {"bufferView": 1, "byteOffset": 0, "componentType": 5126, "count": 228, "type": "VEC3"}, {"bufferView": 1, "byteOffset": 2736, "componentType": 5126, "count": 113, "type": "VEC3"}, {"bufferView": 1, "byteOffset": 4092, "componentType": 5126, "count": 113, "type": "VEC3"}, {"bufferView": 2, "byteOffset": 0, "componentType": 5123, "count": 678, "type": "SCALAR"}, {"bufferView": 2, "byteOffset": 1356, "componentType": 5123, "count": 333, "type": "SCALAR"}, {"bufferView": 2, "byteOffset": 2024, "componentType": 5123, "count": 333, "type": "SCALAR"}], "asset": {"generator": "Open CASCADE Technology 7.7 [dev.opencascade.org]", "version": "2.0"}, "bufferViews": [{"buffer": 0, "byteLength": 5448, "byteOffset": 0, "byteStride": 12, "target": 34962}, {"buffer": 0, "byteLength": 5448, "byteOffset": 5448, "byteStride": 12, "target": 34962}, {"buffer": 0, "byteLength": 2692, "byteOffset": 10896, "target": 34963}], "buffers": [{"byteLength": 13588, "uri": "111-Body.bin"}], "materials": [{"name": "mat_0", "pbrMetallicRoughness": {"baseColorFactor": [0.6038273572921753, 0.6038273572921753, 0.7912984490394592, 1.0]}, "doubleSided": true}], "meshes": [{"name": "Body", "primitives": [{"attributes": {"NORMAL": 3, "POSITION": 0}, "indices": 6, "material": 0, "mode": 4}, {"attributes": {"NORMAL": 4, "POSITION": 1}, "indices": 7, "material": 0, "mode": 4}, {"attributes": {"NORMAL": 5, "POSITION": 2}, "indices": 8, "material": 0, "mode": 4}]}], "nodes": [{"mesh": 0, "name": "Body"}], "scene": 0, "scenes": [{"nodes": [0]}]};
            const accessors = gltfData.accessors;
            const bufferViews = gltfData.bufferViews;
            const meshes = gltfData.meshes;
            
            // 创建几何体数组
            const geometries = [];
            
            // 遍历所有网格
            for (const mesh of meshes) {
              // 遍历网格中的所有图元
              for (const primitive of mesh.primitives) {
                const attributes = primitive.attributes;
                
                // 获取位置数据
                const positionAccessorIndex = attributes.POSITION;
                const positionAccessor = accessors[positionAccessorIndex];
                const positionBufferView = bufferViews[positionAccessor.bufferView];
                const positionOffset = (positionBufferView.byteOffset || 0) + (positionAccessor.byteOffset || 0);
                const positionStride = positionBufferView.byteStride || 12; // 3个float32 = 12字节
                const positionCount = positionAccessor.count;
                
                // 提取位置数据
                const positions = [];
                for (let i = 0; i < positionCount; i++) {
                  const offset = positionOffset + i * positionStride;
                  const x = new Float32Array(buffer.slice(offset, offset + 4))[0];
                  const y = new Float32Array(buffer.slice(offset + 4, offset + 8))[0];
                  const z = new Float32Array(buffer.slice(offset + 8, offset + 12))[0];
                  
                  // 缩放模型以适应屏幕
                  positions.push(x * 20, y * 20, z * 20);
                }
                
                // 获取法线数据（如果有）
                let normals = [];
                if (attributes.NORMAL !== undefined) {
                  const normalAccessorIndex = attributes.NORMAL;
                  const normalAccessor = accessors[normalAccessorIndex];
                  const normalBufferView = bufferViews[normalAccessor.bufferView];
                  const normalOffset = (normalBufferView.byteOffset || 0) + (normalAccessor.byteOffset || 0);
                  const normalStride = normalBufferView.byteStride || 12;
                  const normalCount = normalAccessor.count;
                  
                  for (let i = 0; i < normalCount; i++) {
                    const offset = normalOffset + i * normalStride;
                    const nx = new Float32Array(buffer.slice(offset, offset + 4))[0];
                    const ny = new Float32Array(buffer.slice(offset + 4, offset + 8))[0];
                    const nz = new Float32Array(buffer.slice(offset + 8, offset + 12))[0];
                    normals.push(nx, ny, nz);
                  }
                }
                
                // 获取索引数据
                const indices = [];
                if (primitive.indices !== undefined) {
                  const indexAccessorIndex = primitive.indices;
                  const indexAccessor = accessors[indexAccessorIndex];
                  const indexBufferView = bufferViews[indexAccessor.bufferView];
                  const indexOffset = (indexBufferView.byteOffset || 0) + (indexAccessor.byteOffset || 0);
                  const indexCount = indexAccessor.count;
                  
                  // 根据索引类型读取数据
                  const componentType = indexAccessor.componentType;
                  const bytesPerIndex = componentType === 5123 ? 2 : (componentType === 5125 ? 4 : 1);
                  
                  for (let i = 0; i < indexCount; i++) {
                    const offset = indexOffset + i * bytesPerIndex;
                    let index;
                    
                    if (componentType === 5123) { // UNSIGNED_SHORT
                      index = new Uint16Array(buffer.slice(offset, offset + 2))[0];
                    } else if (componentType === 5125) { // UNSIGNED_INT
                      index = new Uint32Array(buffer.slice(offset, offset + 4))[0];
                    } else { // UNSIGNED_BYTE
                      index = new Uint8Array(buffer.slice(offset, offset + 1))[0];
                    }
                    
                    indices.push(index);
                  }
                }
                
                // 创建几何体
                const geometryAttributes = {
                  aPosition: positions
                };
                
                if (normals.length > 0) {
                  geometryAttributes.aNormal = normals;
                }
                
                const geometry = new Geometry({
                  attributes: geometryAttributes,
                  indexBuffer: indices.length > 0 ? indices : undefined
                });
                
                geometries.push(geometry);
              }
            }
            
            return geometries;
          };
          
          const geometries = createGeometryFromGLTF();
          
          // 创建着色器
          const shader = Shader.from({
            gl: {
              vertex: `
                precision mediump float;
                attribute vec3 aPosition;
                attribute vec3 aNormal;
                
                uniform mat4 uModelMatrix;
                uniform mat4 uViewMatrix;
                uniform mat4 uProjectionMatrix;
                uniform float uTime;
                
                varying vec3 vPosition;
                varying vec3 vNormal;
                varying vec3 vWorldPosition;
                
                void main() {
                  // 应用模型矩阵
                  vec4 worldPosition = uModelMatrix * vec4(aPosition, 1.0);
                  vec4 viewPosition = uViewMatrix * worldPosition;
                  gl_Position = uProjectionMatrix * viewPosition;
                  
                  // 变换法线
                  vNormal = mat3(uModelMatrix) * (aNormal != vec3(0.0) ? aNormal : vec3(0.0, 1.0, 0.0));
                  vPosition = aPosition;
                  vWorldPosition = worldPosition.xyz;
                }
              `,
              fragment: `
                precision mediump float;
                
                varying vec3 vPosition;
                varying vec3 vNormal;
                varying vec3 vWorldPosition;
                uniform float uTime;
                
                void main() {
                  // 光照方向
                  vec3 lightDir = normalize(vec3(sin(uTime * 0.5), 0.7, cos(uTime * 0.5)));
                  
                  // 计算漫反射
                  vec3 normal = normalize(vNormal);
                  float diff = max(dot(normal, lightDir), 0.0);
                  
                  // 基础颜色
                  vec3 baseColor = vec3(0.7, 0.7, 0.8);
                  
                  // 环境光
                  vec3 ambient = baseColor * 0.3;
                  
                  // 漫反射
                  vec3 diffuse = baseColor * diff * 0.7;
                  
                  // 高光
                  vec3 viewDir = normalize(vec3(0.0, 0.0, 1.0) - vWorldPosition);
                  vec3 reflectDir = reflect(-lightDir, normal);
                  float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
                  vec3 specular = vec3(1.0) * spec * 0.3;
                  
                  // 最终颜色
                  vec3 color = ambient + diffuse + specular;
                  
                  gl_FragColor = vec4(color, 1.0);
                }
              `
            },
            resources: {
              uniforms: {
                uTime: { type: 'f32', value: 0.0 },
                uModelMatrix: { 
                  type: 'mat4x4<f32>', 
                  value: [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                  ]
                },
                uViewMatrix: { 
                  type: 'mat4x4<f32>', 
                  value: [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, -5, 1
                  ]
                },
                uProjectionMatrix: { 
                  type: 'mat4x4<f32>', 
                  value: [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                  ]
                }
              }
            }
          });
          
          // 创建透视投影矩阵
          const createPerspectiveMatrix = (fov, aspect, near, far) => {
            const f = 1.0 / Math.tan(fov / 2);
            const nf = 1 / (near - far);
            
            return [
              f / aspect, 0, 0, 0,
              0, f, 0, 0,
              0, 0, (far + near) * nf, -1,
              0, 0, 2 * far * near * nf, 0
            ];
          };
          
          // 设置投影矩阵
          const updateProjectionMatrix = () => {
            const aspect = app.renderer.width / app.renderer.height;
            const projMatrix = createPerspectiveMatrix(Math.PI / 4, aspect, 0.1, 100.0);
            shader.resources.uniforms.uniforms.uProjectionMatrix = projMatrix;
          };
          
          updateProjectionMatrix();
          
          // 创建网格并添加到舞台
          const meshes = [];
          for (const geometry of geometries) {
            const mesh = new Mesh({ geometry, shader });
            app.stage.addChild(mesh);
            meshes.push(mesh);
          }
          
          // 添加窗口大小变化事件
          window.addEventListener('resize', () => {
            app.renderer.resize(window.innerWidth, window.innerHeight);
            updateProjectionMatrix();
          });
          
          // 相机控制
          class OrbitControls {
            constructor(element) {
              this.element = element;
              this.rotationX = 0;
              this.rotationY = 0;
              this.distance = 5;
              this.targetX = 0;
              this.targetY = 0;
              this.targetZ = 0;
              this.damping = 0.1; // 阻尼系数
              
              // 当前状态
              this.isDragging = false;
              this.isRotating = false;
              this.isPanning = false;
              this.previousMouseX = 0;
              this.previousMouseY = 0;
              this.rotationSpeed = 0.01;
              this.panSpeed = 0.01;
              this.zoomSpeed = 0.1;
              
              // 自动旋转
              this.autoRotate = false;
              this.autoRotateSpeed = 0.005;
              
              // 绑定事件
              this.bindEvents();
            }
            
            bindEvents() {
              // 鼠标按下事件
              this.element.addEventListener('mousedown', (e) => {
                if (e.button === 0) { // 左键
                  this.isRotating = true;
                } else if (e.button === 1) { // 中键
                  this.isPanning = true;
                  e.preventDefault(); // 阻止默认的中键滚动行为
                }
                
                this.previousMouseX = e.clientX;
                this.previousMouseY = e.clientY;
              });
              
              // 鼠标抬起事件
              window.addEventListener('mouseup', (e) => {
                this.isRotating = false;
                this.isPanning = false;
              });
              
              // 鼠标移动事件
              window.addEventListener('mousemove', (e) => {
                if (this.isRotating) {
                  const deltaX = e.clientX - this.previousMouseX;
                  const deltaY = e.clientY - this.previousMouseY;
                  
                  this.rotationY += deltaX * this.rotationSpeed;
                  this.rotationX += deltaY * this.rotationSpeed;
                  
                  // 限制垂直旋转角度
                  this.rotationX = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, this.rotationX));
                } else if (this.isPanning) {
                  const deltaX = e.clientX - this.previousMouseX;
                  const deltaY = e.clientY - this.previousMouseY;
                  
                  // 计算平移方向
                  const forward = [
                    Math.sin(this.rotationY) * Math.cos(this.rotationX),
                    -Math.sin(this.rotationX),
                    Math.cos(this.rotationY) * Math.cos(this.rotationX)
                  ];
                  
                  const right = [
                    Math.cos(this.rotationY),
                    0,
                    -Math.sin(this.rotationY)
                  ];
                  
                  const up = [
                    Math.sin(this.rotationY) * Math.sin(this.rotationX),
                    Math.cos(this.rotationX),
                    Math.cos(this.rotationY) * Math.sin(this.rotationX)
                  ];
                  
                  // 应用平移
                  this.targetX -= (right[0] * deltaX + up[0] * deltaY) * this.panSpeed;
                  this.targetY -= (right[1] * deltaX + up[1] * deltaY) * this.panSpeed;
                  this.targetZ -= (right[2] * deltaX + up[2] * deltaY) * this.panSpeed;
                }
                
                this.previousMouseX = e.clientX;
                this.previousMouseY = e.clientY;
              });
              
              // 滚轮事件
              this.element.addEventListener('wheel', (e) => {
                this.distance += e.deltaY * this.zoomSpeed * 0.01;
                this.distance = Math.max(1, Math.min(20, this.distance));
                e.preventDefault();
              });
              
              // 双击事件 - 重置视图
              this.element.addEventListener('dblclick', () => {
                this.reset();
              });
              
              // 触摸事件支持
              this.element.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                  this.isRotating = true;
                } else if (e.touches.length === 2) {
                  this.isPanning = true;
                  // 存储初始触摸点距离，用于缩放
                  const dx = e.touches[0].clientX - e.touches[1].clientX;
                  const dy = e.touches[0].clientY - e.touches[1].clientY;
                  this.initialPinchDistance = Math.sqrt(dx * dx + dy * dy);
                }
                
                this.previousMouseX = e.touches[0].clientX;
                this.previousMouseY = e.touches[0].clientY;
                e.preventDefault();
              });
              
              this.element.addEventListener('touchmove', (e) => {
                if (this.isRotating && e.touches.length === 1) {
                  const deltaX = e.touches[0].clientX - this.previousMouseX;
                  const deltaY = e.touches[0].clientY - this.previousMouseY;
                  
                  this.rotationY += deltaX * this.rotationSpeed;
                  this.rotationX += deltaY * this.rotationSpeed;
                  
                  // 限制垂直旋转角度
                  this.rotationX = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, this.rotationX));
                  
                  this.previousMouseX = e.touches[0].clientX;
                  this.previousMouseY = e.touches[0].clientY;
                } else if (e.touches.length === 2) {
                  // 处理平移
                  const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                  const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                  
                  const deltaX = centerX - this.previousMouseX;
                  const deltaY = centerY - this.previousMouseY;
                  
                  // 计算平移方向
                  const forward = [
                    Math.sin(this.rotationY) * Math.cos(this.rotationX),
                    -Math.sin(this.rotationX),
                    Math.cos(this.rotationY) * Math.cos(this.rotationX)
                  ];
                  
                  const right = [
                    Math.cos(this.rotationY),
                    0,
                    -Math.sin(this.rotationY)
                  ];
                  
                  const up = [
                    Math.sin(this.rotationY) * Math.sin(this.rotationX),
                    Math.cos(this.rotationX),
                    Math.cos(this.rotationY) * Math.sin(this.rotationX)
                  ];
                  
                  // 应用平移
                  this.targetX -= (right[0] * deltaX + up[0] * deltaY) * this.panSpeed;
                  this.targetY -= (right[1] * deltaX + up[1] * deltaY) * this.panSpeed;
                  this.targetZ -= (right[2] * deltaX + up[2] * deltaY) * this.panSpeed;
                  
                  // 处理缩放
                  const dx = e.touches[0].clientX - e.touches[1].clientX;
                  const dy = e.touches[0].clientY - e.touches[1].clientY;
                  const distance = Math.sqrt(dx * dx + dy * dy);
                  
                  if (this.initialPinchDistance) {
                    const scale = distance / this.initialPinchDistance;
                    this.distance /= scale;
                    this.distance = Math.max(1, Math.min(20, this.distance));
                    this.initialPinchDistance = distance;
                  }
                  
                  this.previousMouseX = centerX;
                  this.previousMouseY = centerY;
                }
                
                e.preventDefault();
              });
              
              this.element.addEventListener('touchend', () => {
                this.isRotating = false;
                this.isPanning = false;
                this.initialPinchDistance = null;
              });
            }
            
            reset() {
              this.rotationX = 0;
              this.rotationY = 0;
              this.distance = 5;
              this.targetX = 0;
              this.targetY = 0;
              this.targetZ = 0;
            }
            
            update() {
              if (this.autoRotate && !this.isRotating && !this.isPanning) {
                this.rotationY += this.autoRotateSpeed;
              }
              
              // 计算视图矩阵
              const cx = Math.cos(this.rotationX);
              const sx = Math.sin(this.rotationX);
              const cy = Math.cos(this.rotationY);
              const sy = Math.sin(this.rotationY);
              
              // 计算相机位置
              const cameraX = this.distance * sy * cx + this.targetX;
              const cameraY = this.distance * sx + this.targetY;
              const cameraZ = this.distance * cy * cx + this.targetZ;
              
              // 计算视图矩阵
              const forward = [
                this.targetX - cameraX,
                this.targetY - cameraY,
                this.targetZ - cameraZ
              ];
              
              // 归一化
              const forwardLength = Math.sqrt(
                forward[0] * forward[0] + 
                forward[1] * forward[1] + 
                forward[2] * forward[2]
              );
              
              forward[0] /= forwardLength;
              forward[1] /= forwardLength;
              forward[2] /= forwardLength;
              
              // 计算右向量
              const right = [
                Math.cos(this.rotationY),
                0,
                -Math.sin(this.rotationY)
              ];
              
              // 计算上向量
              const up = [
                forward[1] * right[2] - forward[2] * right[1],
                forward[2] * right[0] - forward[0] * right[2],
                forward[0] * right[1] - forward[1] * right[0]
              ];
              
              // 构建视图矩阵
              const viewMatrix = [
                right[0], up[0], -forward[0], 0,
                right[1], up[1], -forward[1], 0,
                right[2], up[2], -forward[2], 0,
                -(right[0] * cameraX + right[1] * cameraY + right[2] * cameraZ),
                -(up[0] * cameraX + up[1] * cameraY + up[2] * cameraZ),
                forward[0] * cameraX + forward[1] * cameraY + forward[2] * cameraZ,
                1
              ];
              
              return viewMatrix;
            }
          }
          
          // 创建轨道控制器
          const controls = new OrbitControls(app.view);
          
          // 添加键盘控制
          window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            
            // 按R键重置视图
            if (key === 'r') {
              controls.reset();
            }
            
            // 按空格键切换自动旋转
            if (e.code === 'Space') {
              controls.autoRotate = !controls.autoRotate;
              e.preventDefault();
            }
          });
          
          let time = 0;
          // 添加动画
          app.ticker.add(() => {
            time += 1 / 60;
            
            // 更新时间uniform
            shader.resources.uniforms.uniforms.uTime = time;
            
            // 更新视图矩阵
            shader.resources.uniforms.uniforms.uViewMatrix = controls.update();
            
            // 更新模型矩阵
            const modelMatrix = [
              1, 0, 0, 0,
              0, 1, 0, 0,
              0, 0, 1, 0,
              0, 0, 0, 1
            ];
            
            shader.resources.uniforms.uniforms.uModelMatrix = modelMatrix;
          });
          
          console.log('3D 模型渲染已成功初始化');
        } catch (error) {
          console.error('初始化错误:', error);
          document.body.innerHTML = `<div style="color: red; padding: 20px;">
            <h2>渲染错误</h2>
            <pre>${error.toString()}</pre>
          </div>`;
        }
      })();
    </script>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #1a1a1a;
      }
      canvas {
        display: block;
      }
      .info {
        position: absolute;
        bottom: 10px;
        left: 10px;
        color: white;
        font-family: Arial, sans-serif;
        background-color: rgba(0, 0, 0, 0.5);
        padding: 5px 10px;
        border-radius: 5px;
      }
    </style>
  </head>
  <body>
    <div class="info">
      左键拖动: 旋转模型 | 中键拖动: 平移视图 | 滚轮: 缩放 | 双击: 重置视图 | 空格: 自动旋转
    </div>
  </body>
</html>
